syntax = "proto3";

// `java_package` must match the package name you declare for `androidPackage` in your pubspec.yaml
option java_package = "org.beatscratch.messages";

// NoteName corresponds to "white keys" (notes A-G)
enum NoteLetter {
  C = 0;
  D = 1;
  E = 2;
  F = 3;
  G = 4;
  A = 5;
  B = 6;
};

enum NoteSign {
  natural = 0;
  flat = 1;
  double_flat = 2;
  sharp = 3;
  double_sharp = 4;
}

// Describes notes as pitch classes (i.e. without octave)
message NoteName {
  NoteLetter note_letter = 1;
  NoteSign note_sign = 2;
}

message NoteSpecification {
  NoteLetter note_letter = 1;
  // In rendering applications
  NoteSign note_sign = 2;
  sint32 octave = 3;
}

message Chord {
  NoteName root_note = 1;
  // Optional. When note provided, applications referencing bass_note should generally
  // be able to revert to root_note.
  NoteName bass_note = 2;
  // 11-bit bit-set value from 0-2047. Bits (in order from msb to lsb) indicate presence of the
  // minor 2, major 2, minor 3, major 3, ..., major 7 of the chord. Some examples:
  // * 0 = 0b00000000000 is a chord of just the root note with no other notes.
  // * 144 = 0b00010010000 is a regular Major chord.
  // * 145 = 0b00010010001 is a Major 7 (M7) chord.
  // * A neat math thing: every odd extension has a M7 in it. Every even one does not.
  // * 2047 = 0b11111111111 is a chromatic scale rooted at root_note.
  // * 725 = 0b01011010101 is a major scale or a M13(11) chord (which are the same thing).
  //
  // With music theory, the idea is that we can derive the Note (i.e., differentiate whether these
  // should be a C# or Db) for all the tones in the extension based on the root_note and bass_note.
  uint32 extension = 3;
}

// A Harmony is a rhythmic mapping of chords.
message Harmony {
  string id = 1;
  uint32 subdivisions_per_beat = 2;
  // Length in subdivisions (so, length in beats is length / subdivisions_per_beat)
  uint32 length = 3;
  // Must contain at least one entry with key less than Harmony length. Generally, should contain
  // an entry at 0.
  map<sint32, Chord> data = 4;
}

enum InstrumentType {
  // Represents actual tones, with a basis of "tones" of C4 = 0.
  harmonic = 0;
  // Represents MIDI drum tones (so B1, below C2, is a kick, F#2 is a hat, etc.) from C4 = 0
  drum = 1;
}

enum MelodyType {
  // Uses MelodyAttacks and represents instrument data for touch editing
  melodic = 0;
  // Uses MidiChanges and represents raw MIDI instrument data
  midi = 1;
}

// A "classical" notion of a slice of a melody defined to be easy to analyze, draw on a screen
// and make touchable. A "rest" is any MelodyAttack with no tones. MelodyAttacks can represent a
// traditional "music theory class" single-note melody, but expanded slightly so that we can have
// multiple notes. Notes must all attack at once and release at once.
//
// To phrase it more simply, this way of breaking down melodies forces you to separate your
// soprano from your bass part. Unless they're singing the exact same rhythm the entire time.
message MelodyAttack {
  repeated sint32 tones = 1;
  float velocity = 2;
}

// Represents raw midi data (corresponding to a subidivision in a melody). Can include NOTE ON,
// NOTE OFF, knobby things, etc. Playback engine is responsible for modifying channel from original
// recorded MIDI messages at playback time.
//
// To phrase it more simply, this way of breaking down melodies will let you represent your soprano
// and bass parts as a single "melody." But your music theory teach would berate you in class for
// that. These are also harder to make editable by touch, but handy for recording MIDI performance
// by a musician.
message MidiChange {
  uint32 length = 1;
  repeated uint32 data = 2;
}

message Melody {
  // Unique identifier for a Melody. Should be kept unique within a given Score.
  string id = 1;
  // Optional name for the Melody.
  string name = 2;
  // How many subdivisions per beat the melody is in. Allowed values are 1-24 (MIDI beat clock max).
  // 1 per beat is quarter notes in 4/4 time; 3 is triplet eighths; 4 is sixteenths; 6 is triplet
  // sixteenths; etc.
  uint32 subdivisions_per_beat = 3;
  // Length in subdivisions (so, length in beats is length / subdivisions_per_beat)
  uint32 length = 4;
  // Indicates what type of data (attacks only or full MIDI) this melody uses.
  MelodyType type = 5;
  // Indicates what type of instrument the Melody is for. In the context of a Score,
  // should match the Part's instrument type. Useful for letting the user copy/paste Melodies
  // between Parts.
  InstrumentType instrument_type = 6;
  // Used for MelodyType.melodic type.
  map<sint32, MelodyAttack> melodic_data = 7;
  // Used for MelodyType.midi type.
  map<sint32, MidiChange> midi_data = 8;
}

message Instrument {
  string name = 1;
  InstrumentType type = 2;
  float volume = 3;
  // Used by InstrumentType.midi_harmonic and InstrumentType.midi_drum
  uint32 midi_channel = 4;
  // Used by InstrumentType.midi_harmonic and InstrumentType.midi_drum
  uint32 midi_instrument = 5;
  // Used by InstrumentType.midi_harmonic and InstrumentType.midi_drum
  uint32 midi_gm2_msb = 6;
  // Used by InstrumentType.midi_harmonic and InstrumentType.midi_drum
  uint32 midi_gm2_lsb = 7;
}

message Part {
  string id = 1;
  Instrument instrument = 3;
  repeated Melody melodies = 4;
}

message MelodyReference {
  enum PlaybackType {
    disabled = 0;
    playback_indefinitely = 1;
  }
  string melody_id = 1;
  PlaybackType playback_type = 2;
  // Volume, between 0 and 1.
  float volume = 3;
}

message Section {
  string id = 1;
  string name = 2;
  Harmony harmony = 3;
  // Maps Part.ids to melodies
  repeated MelodyReference melodies = 4;
}

message Score {
  string id = 1;
  string name = 2;
  repeated Part parts = 3;
  repeated Section sections = 4;
}