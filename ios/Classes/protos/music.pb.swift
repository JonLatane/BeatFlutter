// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protos/music.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// NoteName corresponds to "white keys" (notes A-G)
enum NoteName: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case c // = 0
  case d // = 1
  case e // = 2
  case f // = 3
  case g // = 4
  case a // = 5
  case b // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .c
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .c
    case 1: self = .d
    case 2: self = .e
    case 3: self = .f
    case 4: self = .g
    case 5: self = .a
    case 6: self = .b
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .c: return 0
    case .d: return 1
    case .e: return 2
    case .f: return 3
    case .g: return 4
    case .a: return 5
    case .b: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NoteName: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [NoteName] = [
    .c,
    .d,
    .e,
    .f,
    .g,
    .a,
    .b,
  ]
}

#endif  // swift(>=4.2)

enum NoteSign: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case natural // = 0
  case none // = 1
  case flat // = 2
  case doubleFlat // = 3
  case sharp // = 4
  case doubleSharp // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .natural
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .natural
    case 1: self = .none
    case 2: self = .flat
    case 3: self = .doubleFlat
    case 4: self = .sharp
    case 5: self = .doubleSharp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .natural: return 0
    case .none: return 1
    case .flat: return 2
    case .doubleFlat: return 3
    case .sharp: return 4
    case .doubleSharp: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NoteSign: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [NoteSign] = [
    .natural,
    .none,
    .flat,
    .doubleFlat,
    .sharp,
    .doubleSharp,
  ]
}

#endif  // swift(>=4.2)

enum MelodyType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Uses MelodyAttacks
  case melodyHarmonic // = 0
  case melodyDrum // = 1
  case midiHarmonic // = 2
  case midiDrum // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .melodyHarmonic
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .melodyHarmonic
    case 1: self = .melodyDrum
    case 2: self = .midiHarmonic
    case 3: self = .midiDrum
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .melodyHarmonic: return 0
    case .melodyDrum: return 1
    case .midiHarmonic: return 2
    case .midiDrum: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MelodyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [MelodyType] = [
    .melodyHarmonic,
    .melodyDrum,
    .midiHarmonic,
    .midiDrum,
  ]
}

#endif  // swift(>=4.2)

enum InstrumentType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case harmonic // = 0
  case drum // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .harmonic
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .harmonic
    case 1: self = .drum
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .harmonic: return 0
    case .drum: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension InstrumentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [InstrumentType] = [
    .harmonic,
    .drum,
  ]
}

#endif  // swift(>=4.2)

struct Note {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var noteName: NoteName = .c

  var noteSign: NoteSign = .natural

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Chord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rootNote: Note {
    get {return _storage._rootNote ?? Note()}
    set {_uniqueStorage()._rootNote = newValue}
  }
  /// Returns true if `rootNote` has been explicitly set.
  var hasRootNote: Bool {return _storage._rootNote != nil}
  /// Clears the value of `rootNote`. Subsequent reads from it will return its default value.
  mutating func clearRootNote() {_uniqueStorage()._rootNote = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A Harmony is a rhythmic mapping of chords.
struct Harmony {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var subdivisionsPerBeat: UInt32 = 0

  /// Length in subdivisions (so, length in beats is length / subdivisions_per_beat)
  var length: UInt32 = 0

  /// Cannot be empty for a valid harmony. Generally, should contain an attack at 0.
  var data: Dictionary<Int32,Chord> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MelodyAttack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MidiChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Melody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var subdivisionsPerBeat: UInt32 = 0

  /// Length in subdivisions (so, length in beats is length / subdivisions_per_beat)
  var length: UInt32 = 0

  /// Indicates what type of data (attacks only or full MIDI) this melody uses.
  var type: MelodyType = .melodyHarmonic

  /// Used for MelodyType.melody_harmonic and MelodyType.melody_drum
  var attackData: Dictionary<Int32,MelodyAttack> = [:]

  /// Used for MelodyType.midi_harmonic and MelodyType.midi_drum
  var midiData: Dictionary<Int32,MelodyAttack> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Instrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var type: InstrumentType = .harmonic

  var volume: Float = 0

  /// Used by InstrumentType.midi_harmonic and InstrumentType.midi_drum
  var midiChannel: UInt32 = 0

  /// Used by InstrumentType.midi_harmonic and InstrumentType.midi_drum
  var midiInstrument: UInt32 = 0

  /// Used by InstrumentType.midi_harmonic and InstrumentType.midi_drum
  var midiGm2Msb: UInt32 = 0

  /// Used by InstrumentType.midi_harmonic and InstrumentType.midi_drum
  var midiGm2Lsb: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Part {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var instrument: Instrument {
    get {return _storage._instrument ?? Instrument()}
    set {_uniqueStorage()._instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  var hasInstrument: Bool {return _storage._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  mutating func clearInstrument() {_uniqueStorage()._instrument = nil}

  var melodies: [Melody] {
    get {return _storage._melodies}
    set {_uniqueStorage()._melodies = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct MelodyReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var melodyID: String = String()

  /// Volume, between 0 and 1.
  var volume: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Section {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var harmony: Harmony {
    get {return _storage._harmony ?? Harmony()}
    set {_uniqueStorage()._harmony = newValue}
  }
  /// Returns true if `harmony` has been explicitly set.
  var hasHarmony: Bool {return _storage._harmony != nil}
  /// Clears the value of `harmony`. Subsequent reads from it will return its default value.
  mutating func clearHarmony() {_uniqueStorage()._harmony = nil}

  /// Maps Part.ids to melodies
  var melodies: [MelodyReference] {
    get {return _storage._melodies}
    set {_uniqueStorage()._melodies = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Score {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var parts: [Part] = []

  var sections: [Section] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension NoteName: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "C"),
    1: .same(proto: "D"),
    2: .same(proto: "E"),
    3: .same(proto: "F"),
    4: .same(proto: "G"),
    5: .same(proto: "A"),
    6: .same(proto: "B"),
  ]
}

extension NoteSign: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "natural"),
    1: .same(proto: "none"),
    2: .same(proto: "flat"),
    3: .same(proto: "double_flat"),
    4: .same(proto: "sharp"),
    5: .same(proto: "double_sharp"),
  ]
}

extension MelodyType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "melody_harmonic"),
    1: .same(proto: "melody_drum"),
    2: .same(proto: "midi_harmonic"),
    3: .same(proto: "midi_drum"),
  ]
}

extension InstrumentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "harmonic"),
    1: .same(proto: "drum"),
  ]
}

extension Note: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Note"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "note_name"),
    2: .standard(proto: "note_sign"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.noteName)
      case 2: try decoder.decodeSingularEnumField(value: &self.noteSign)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.noteName != .c {
      try visitor.visitSingularEnumField(value: self.noteName, fieldNumber: 1)
    }
    if self.noteSign != .natural {
      try visitor.visitSingularEnumField(value: self.noteSign, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Note, rhs: Note) -> Bool {
    if lhs.noteName != rhs.noteName {return false}
    if lhs.noteSign != rhs.noteSign {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Chord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_note"),
  ]

  fileprivate class _StorageClass {
    var _rootNote: Note? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rootNote = source._rootNote
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._rootNote)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._rootNote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Chord, rhs: Chord) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rootNote != rhs_storage._rootNote {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Harmony: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Harmony"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "subdivisions_per_beat"),
    3: .same(proto: "length"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.subdivisionsPerBeat)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.length)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufSInt32,Chord>.self, value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.subdivisionsPerBeat != 0 {
      try visitor.visitSingularUInt32Field(value: self.subdivisionsPerBeat, fieldNumber: 2)
    }
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufSInt32,Chord>.self, value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Harmony, rhs: Harmony) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.subdivisionsPerBeat != rhs.subdivisionsPerBeat {return false}
    if lhs.length != rhs.length {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MelodyAttack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MelodyAttack"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MelodyAttack, rhs: MelodyAttack) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MidiChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MidiChange"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MidiChange, rhs: MidiChange) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Melody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Melody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "subdivisions_per_beat"),
    3: .same(proto: "length"),
    4: .same(proto: "type"),
    5: .standard(proto: "attack_data"),
    6: .standard(proto: "midi_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.subdivisionsPerBeat)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.length)
      case 4: try decoder.decodeSingularEnumField(value: &self.type)
      case 5: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufSInt32,MelodyAttack>.self, value: &self.attackData)
      case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufSInt32,MelodyAttack>.self, value: &self.midiData)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.subdivisionsPerBeat != 0 {
      try visitor.visitSingularUInt32Field(value: self.subdivisionsPerBeat, fieldNumber: 2)
    }
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 3)
    }
    if self.type != .melodyHarmonic {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.attackData.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufSInt32,MelodyAttack>.self, value: self.attackData, fieldNumber: 5)
    }
    if !self.midiData.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufSInt32,MelodyAttack>.self, value: self.midiData, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Melody, rhs: Melody) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.subdivisionsPerBeat != rhs.subdivisionsPerBeat {return false}
    if lhs.length != rhs.length {return false}
    if lhs.type != rhs.type {return false}
    if lhs.attackData != rhs.attackData {return false}
    if lhs.midiData != rhs.midiData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Instrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Instrument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "volume"),
    4: .standard(proto: "midi_channel"),
    5: .standard(proto: "midi_instrument"),
    6: .standard(proto: "midi_gm2_msb"),
    7: .standard(proto: "midi_gm2_lsb"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularFloatField(value: &self.volume)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.midiChannel)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.midiInstrument)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.midiGm2Msb)
      case 7: try decoder.decodeSingularUInt32Field(value: &self.midiGm2Lsb)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .harmonic {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.volume != 0 {
      try visitor.visitSingularFloatField(value: self.volume, fieldNumber: 3)
    }
    if self.midiChannel != 0 {
      try visitor.visitSingularUInt32Field(value: self.midiChannel, fieldNumber: 4)
    }
    if self.midiInstrument != 0 {
      try visitor.visitSingularUInt32Field(value: self.midiInstrument, fieldNumber: 5)
    }
    if self.midiGm2Msb != 0 {
      try visitor.visitSingularUInt32Field(value: self.midiGm2Msb, fieldNumber: 6)
    }
    if self.midiGm2Lsb != 0 {
      try visitor.visitSingularUInt32Field(value: self.midiGm2Lsb, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Instrument, rhs: Instrument) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.midiChannel != rhs.midiChannel {return false}
    if lhs.midiInstrument != rhs.midiInstrument {return false}
    if lhs.midiGm2Msb != rhs.midiGm2Msb {return false}
    if lhs.midiGm2Lsb != rhs.midiGm2Lsb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Part: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Part"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .same(proto: "instrument"),
    4: .same(proto: "melodies"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _instrument: Instrument? = nil
    var _melodies: [Melody] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _instrument = source._instrument
      _melodies = source._melodies
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._instrument)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._melodies)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._instrument {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._melodies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._melodies, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Part, rhs: Part) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._instrument != rhs_storage._instrument {return false}
        if _storage._melodies != rhs_storage._melodies {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MelodyReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MelodyReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "melody_id"),
    2: .same(proto: "volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.melodyID)
      case 2: try decoder.decodeSingularFloatField(value: &self.volume)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.melodyID.isEmpty {
      try visitor.visitSingularStringField(value: self.melodyID, fieldNumber: 1)
    }
    if self.volume != 0 {
      try visitor.visitSingularFloatField(value: self.volume, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MelodyReference, rhs: MelodyReference) -> Bool {
    if lhs.melodyID != rhs.melodyID {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Section: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Section"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "harmony"),
    4: .same(proto: "melodies"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _harmony: Harmony? = nil
    var _melodies: [MelodyReference] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _harmony = source._harmony
      _melodies = source._melodies
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._harmony)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._melodies)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if let v = _storage._harmony {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._melodies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._melodies, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Section, rhs: Section) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._harmony != rhs_storage._harmony {return false}
        if _storage._melodies != rhs_storage._melodies {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Score: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Score"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "parts"),
    4: .same(proto: "sections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.parts)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.sections)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.parts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parts, fieldNumber: 3)
    }
    if !self.sections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sections, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Score, rhs: Score) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.parts != rhs.parts {return false}
    if lhs.sections != rhs.sections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
